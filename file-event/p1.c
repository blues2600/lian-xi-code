/*
 * 编写一个程序，针对其命令行参数所指定的目录，记录所有的文件创建、删除和改
 * 名操作。该程序应能够监控指定目录下所有子目录中的事件。获得所有子目录的列
 * 表需使用 nftw()（参见 18.9 节）。当在目录树下添加或删除了子目录时，受监控的
 * 子目录集合应能保持同步更新。
 */

/*
 * 任务解析
 * 1.监控目录，范围包含目录中所有子目录
 * 2.监控类型：创建、删除、改名
 * 3.子目录修改后，监控范围同步修改
 */

/*
 * 思考
 * 总结inotify机制的行为
 * 关注nftw()与监控机制的结合
 * 考虑任务解析的第3点
 */

/*
 * inotify机制的原理和行为
 * 1.新建监控实例inotify_init()
 * 2.通知监控实例，要监控什么对象(char *)，以及监控该对象的哪些行为inotify_add_watch()
 * 3.从监控实例读取时间消息（如果有的话）
 * 4.打印消息
 */

/*
 * 监控整个目录树,nftw()与监控机制的结合
 * - 要监控整个目录树就要利用nftw(),为什么？
 * - 因为nftw遍历dirpath路径下包含的所有文件，它会获得文件的路径、文件的详细信息、目录深度、文件类型等等
 * - 而且它还对每个文件都执行一次fn函数
 * - 那么，有了文件路径，以及可以对文件执行一次fn函数，就可以在这里通知监控示例，要监控什么对象，以及监控它的哪些行为
 *
 */

/*
 * 子目录修改后，监控范围的调整
 * 1.从inotify_add_watch()的行为可知，路径（它描述了一个对象）对应着监控描述符（也描述了一个对象）
 * 2.inotify机制中的监控范围无法可视化修改，只能建立   路径 --- 描述符   表来将被监控对象和inotify机制联系起来
 * 3.这就要求，任何监控范围的变动，都意味着上表的变动
 *
 * 目录添加--和它所带来的变动
 * 1.目录添加，意味着增加监控范围
 * 2.监控范围增加，则路径-描述符对应表的内容增加
 * 3.为了监控新增目录下的子目录和文件，需要再次启用nftw遍历机制
 *
 * 目录删除--和它所带来的变动
 * 1.目录删除，意味着减少监控范围
 * 2.监控范围的减少，则路径-描述符对应表的内容减少
 * 3.当路径-描述符对应表中的路劲字段中包含被删除目录，则该监控描述符删除inotify_rm_watch()
 * 4.之后，路径-描述符对应表的条目删除
 *
 */

/*
 * 程序设计 - 功能分组（大块）
 * 1.新建一个监控示例
 * 2.添加一个监控对象
 * 3.存储路径 - 描述符表的数据结构
 * 4.向路径- 描述符表添加条目
 * 5.从路径- 描述符表删除条目
 * 6.删除一个监控对象
 * 7.从一个监控实例读取监控事件消息
 * 8.输出监控事件消息
 * 9.遍历目录树
 * 10.目录新增事件探测(从这里开始，需要更好的理解inotify 事件才能继续设计)
 * 11.目录删除事件探测
 * 12.文件新增事件探测
 * 13.文件删除事件探测
 */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
